## Temas puntuales de la secci√≥n
Esta es una secci√≥n peque√±a en la cual quiero mostrarles un par de formas de generar identificadores √∫nicos de forma autom√°tica y tambi√©n consideraciones.
Aqu√≠ veremos:
- SERIAL
- Identity
- Llave primaria compuesta
- UUIDs
- Secuencias personalizadas

Esto con el objetivo de poder determinar cu√°l puede servirme y sus consideraciones.

## SERIAL VS IDENTITY

-- QUERY 1: M√©todo tradicional con SERIAL
-- Esto es como tener un contador autom√°tico que empieza en 1 y va de 1 en 1 (1, 2, 3, 4...)
-- Es la forma m√°s simple y com√∫n de crear IDs autom√°ticos
```

## üèÜ CONCLUSI√ìN Y COMPARATIVA

### ¬øCu√°l es el M√ÅS USADO?
**SERIAL** sigue siendo el m√°s popular porque:
- Es m√°s f√°cil de escribir
- Funciona en versiones antiguas de PostgreSQL
- La mayor√≠a de tutoriales lo usan

### üìä COMPARATIVA COMPLETA

| M√©todo | Facilidad | Flexibilidad | Control | Recomendado para |
|--------|-----------|--------------|---------|------------------|
| **SERIAL** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê | Principiantes, proyectos simples |
| **BY DEFAULT** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | Proyectos nuevos, migraci√≥n de datos |
| **ALWAYS** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Sistemas cr√≠ticos, m√°xima seguridad |
| **ALWAYS + par√°metros** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Casos espec√≠ficos, numeraci√≥n especial |

### üéØ MI RECOMENDACI√ìN PERSONAL

**Para estudiantes que empiezan:** Usa **SERIAL**
- Es lo m√°s f√°cil
- Funciona siempre
- No te complicas la vida

**Para proyectos profesionales nuevos:** Usa **GENERATED BY DEFAULT AS IDENTITY**
- Es el est√°ndar moderno
- Te da flexibilidad si la necesitas
- Es lo que PostgreSQL recomienda ahora

**Para sistemas bancarios/cr√≠ticos:** Usa **GENERATED ALWAYS AS IDENTITY**
- Control total
- Nadie puede meter n√∫meros raros
- M√°xima seguridad

### üí° CONSEJO DE ORO
Si est√°s aprendiendo, empieza con **SERIAL**. Cuando ya domines PostgreSQL, cambia a **GENERATED BY DEFAULT AS IDENTITY**. Es como aprender a manejar: primero autom√°tico, despu√©s manual. üöóSQL
CREATE TABLE "users" (
    "user_id" SERIAL PRIMARY KEY,
    "username" VARCHAR
);
```

-- QUERY 2: M√©todo moderno con GENERATED BY DEFAULT
-- Es como SERIAL pero m√°s moderno. "BY DEFAULT" significa que PostgreSQL genera el n√∫mero autom√°ticamente,
-- PERO si t√∫ quieres, puedes insertar tu propio n√∫mero manualmente
-- Ejemplo: PostgreSQL pone 1, 2, 3... pero t√∫ puedes insertar 999 si quieres
```SQL
CREATE TABLE "users" (
    "user_id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "username" VARCHAR
);
```

-- QUERY 3: M√©todo estricto con GENERATED ALWAYS
-- Es como el anterior PERO m√°s estricto. "ALWAYS" significa que PostgreSQL SIEMPRE genera el n√∫mero
-- T√∫ NO puedes insertar tu propio n√∫mero, PostgreSQL tiene el control total
-- Si intentas poner tu propio n√∫mero, te dar√° error
```SQL
CREATE TABLE "users" (
    "user_id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    "username" VARCHAR
);
```

-- QUERY 4: M√©todo personalizado con par√°metros
-- Es como el QUERY 3 pero con reglas especiales:
-- START WITH 100: En lugar de empezar en 1, empieza en 100
-- INCREMENT BY 2: En lugar de ir de 1 en 1, va de 2 en 2
-- Resultado: 100, 102, 104, 106, 108... (n√∫meros pares empezando en 100)
```SQL
CREATE TABLE "users" (
    "user_id" INTEGER GENERATED ALWAYS AS IDENTITY (START WITH 100 INCREMENT BY 2) PRIMARY KEY,
    "username" VARCHAR
);
```

## LLave primaria compuesta


La combinacion de columnas en la llave primaria se denomina llave primaria compuesta. La combinacion no se puede repetir.
```SQL
CREATE TABLE usersDual(
    id1 int,
    id2 int,
    PRIMARY KEY (id1, id2)
);
```

## Los UUIDs

Identificadores √∫nicos globales, pueden usarse como llave primaria. El cliente debe generar el UUID y mandarlo a la base de datos,
El UUID se genera con la funci√≥n gen_random_uuid(), que es parte de la extensi√≥n pgcrypto.
```SQL
SELECT gen_random_uuid();
```

Creando una exptension
```SQL
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```
Si queremos eliminar la extensi√≥n
```SQL
DROP EXTENSION IF EXISTS "uuid-ossp";
```

```SQL
CREATE TABLE "users" (
    "user_id" UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    "username" VARCHAR
);
```

## Secuencias üî¢

-- Las SECUENCIAS son como m√°quinas contadoras independientes que puedes usar donde quieras
-- Es como tener un contador separado que no est√° atado a ninguna tabla espec√≠fica
-- Puedes usar la misma secuencia en varias tablas o columnas diferentes

```SQL
CREATE SEQUENCE "user_sequence"
    START WITH 1        -- Empieza contando desde el n√∫mero 1
    INCREMENT BY 100    -- Cada vez que pidas un n√∫mero, suma 100 (1, 101, 201, 301...)
    NO MINVALUE        -- No tiene l√≠mite m√≠nimo (puede ir hacia n√∫meros negativos si es necesario)
    NO MAXVALUE        -- No tiene l√≠mite m√°ximo (puede contar hasta el infinito... bueno, casi)
    CACHE 1;           -- Guarda solo 1 n√∫mero en memoria (m√°s lento pero m√°s seguro)
```

-- ¬øC√≥mo funciona esto?
-- 1ra vez que pidas un n√∫mero: te da 1
-- 2da vez que pidas un n√∫mero: te da 101 (1 + 100)
-- 3ra vez que pidas un n√∫mero: te da 201 (101 + 100)
-- 4ta vez que pidas un n√∫mero: te da 301 (201 + 100)
-- Y as√≠ sucesivamente...

## üéÆ C√ìMO USAR LA SECUENCIA

### üìà NEXTVAL - "Dame el siguiente n√∫mero"
-- Es como presionar el bot√≥n "SIGUIENTE" en la m√°quina contadora
-- Cada vez que lo usas, la secuencia avanza y te da el pr√≥ximo n√∫mero
```SQL
SELECT nextval('user_sequence');
```
-- 1ra vez: te da 1 (y la secuencia queda en 1)
-- 2da vez: te da 101 (y la secuencia queda en 101) 
-- 3ra vez: te da 201 (y la secuencia queda en 201)
-- ¬°IMPORTANTE! Cada vez que usas nextval(), la secuencia AVANZA

### üëÄ CURRVAL - "¬øCu√°l fue el √∫ltimo n√∫mero que me diste?"
-- Es como preguntarle a la m√°quina: "¬øcu√°l fue el √∫ltimo n√∫mero que me diste?"
-- NO avanza la secuencia, solo te muestra el valor actual
-- ‚ö†Ô∏è CUIDADO: Solo funciona si ya usaste nextval() antes en la misma sesi√≥n
```SQL
SELECT currval('user_sequence');
```
-- Si el √∫ltimo nextval() te dio 201, currval() te mostrar√° 201
-- Si usas currval() sin haber usado nextval() antes, te dar√° ERROR

### üéØ EJEMPLO PR√ÅCTICO:
```sql
-- Paso 1: Pedir el siguiente n√∫mero
SELECT nextval('user_sequence');  -- Resultado: 1

-- Paso 2: Ver cu√°l fue el √∫ltimo n√∫mero (sin avanzar)
SELECT currval('user_sequence');  -- Resultado: 1

-- Paso 3: Pedir otro n√∫mero
SELECT nextval('user_sequence');  -- Resultado: 101

-- Paso 4: Ver cu√°l fue el √∫ltimo n√∫mero
SELECT currval('user_sequence');  -- Resultado: 101
```

Crear llaves primarias con secuencias autoincrementales

```SQL
CREATE SEQUENCE user_sequence;
```
```SQL
CREATE TABLE "users" (
    "user_id" INTEGER PRIMARY KEY DEFAULT nextval('user_sequence'),
    "username" VARCHAR
);
```